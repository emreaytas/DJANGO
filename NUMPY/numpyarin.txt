####################################################################################################################################################################################################################################################################################################################################

en çok kullanılan bilimsel hesaplama kütüphanesidir. açık kaynak kodlu güçlü sayısal işlemler için kullanılan bir python kütüphanesidir.

import numpy as np # core kodu c dilinde yazılmıştır. numpy çok dilli olarak modellenmiştir.

x = np.array([1,2,3,4,5,6]) # bir array oluşturmak için ([]) yapısı ile koymak lazım direkt olarak verileri koymak hata olur. her birini farklı bir yapı olarak kabul eder o yüzden bir arrayin elemanlarını bir liste içerisinde göndermek ve o listenden bir array elde etmek lazım.

# numpy'in temel veri elemanı çok boyutlu dizinlerdir. vektör ve matris ifadelerini daha kolay modellememizi sağlar. 

nupmy klasik pythondan daha hızlıdır. bu yüzden kullanılır zaten. sayılarla işlem yapmak için kullanılır genel olarak.



///Ders 1 - NDArray Oluşturmak - Upcasting//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

NDArray = numpy'nin temel veri yapısıdır. çok boyutlu dizin demektir NDArray 


        import numpy as np
        import time

        baslangic = time.time()

        A = np.arange(10000000) # 10000000 tane eleman oluşturduk. 0'dan 10000000'a kadar birer birer 

        bitis = time.time()


        baslangic1 = time.time()

        L = range(10000000)
        [i for i in L]

        bitis1 = time.time()

        print(bitis - baslangic) # 0.007336139678955078

        print(bitis1 - baslangic1) # 0.8526325225830078

        print((bitis1 - baslangic1) / (bitis - baslangic)) # 95.46080806942409 kat fark var arada buna dikkat etmek gerekir.    


numpy vektörleşmeyi destekler... klasik python listesi ise vektörleşmeyi desteklemez. 

python listesi kullanarak NDArray oluşturmak ->  X = np.array([1,2,3,4,5,6]) # bu metota listeyi gönderince istenen yapıyı elde ederiz. bir array elde ederiz.
                                                   
        import numpy as np

        X = np.array([1,2,3,4,5])
        print(type(X)) # <class 'numpy.ndarray'>

...............


            import numpy as np

            X = np.array([1,2,3,4,5])

            print(X.shape)  # (5,) // boyut olarak bize bilgi verdi shape (5,) demek tek boyutlu 5 elemanlı demektir. bir tuple içerisinde gönderir eksendeki elemanların sayısını gösterir. 
            print(X.size)   # 5 // .size ile kaç adet eleman olduğunu görürüz. toplam eleman sayısını görürüz.
            print(X.ndim)   # 1 // array'in boyutunu bize gösterir. 1 boyutludur bu array. 
            print(X.nbytes) # 20 // veriler ne kadar byte kaplıyor görürüz.  .nbytes ile totalde kaplanan alanı görürüz. veriyi depolamak için gereken byte miktarını verir...
            print(X.dtype)  # int32 // içerisindeki elemanların veri tipini gösterir.  


................

            import numpy as np

            Y = np.array([[1,2,3],[4,5,6],[7,8,9]]) # listelerin listesi ile bir matris elde ederiz. np.array() metotuna yollarız ve bize bir matris döner bu yapı ile.

            print(Y) 
            """             [[1 2 3]
                            [4 5 6]
                            [7 8 9]]"""
                            
            print(type(Y))  # <class 'numpy.ndarray'>
            print(Y.shape)  # (3, 3) // boyut bilgisini verdi 3e 3lük bir yapısı var demektir. önce kaç adet satır olduğu sonra satırlarda kaçar eleman olduğunu yazar eğer [[1,2,3],[4,5,6]] olsa idi (2,3) verirdi
            print(Y.size)   # 9 // .size ile kaç adet eleman olduğunu görürüz. toplam eleman sayısını görürüz.
            print(Y.ndim)   # 2 // array'in boyutunu bize gösterir. 2 boyutludur bu array. yani matris diyebiliriz.
            print(Y.nbytes) # 36 // veriler ne kadar byte kaplıyor görürüz.  .nbytes ile totalde kaplanan alanı görürüz. veriyi depolamak için gereken byte miktarını verir...
            print(Y.dtype)  # int32 // içerisindeki elemanların veri tipini gösterir.  

.................

            import numpy as np

            Z = np.array([[[1,2],[3,4]],[[1,2],[3,4]]]) #buda üç boyutlu bir dizi oldu. içerisinde matrisler taşıyan dizi'ye 3 boyutlu dizi denir...

            print(Z)
            """
            [[
            [1 2]
            [3 4]
            
            ]
            [
                
            [1 2]
            [3 4]
            
            ]]  
                """

            print(Z.shape) #(2, 2, 2)
            print(Z.nbytes) # ne kadar byte kullandık bunu gösterir.
            print(Z.ndim) #3 boyutlu olduğnu gösterir.

................

ndarray'de elemaların tamamı aynı tip olmalıdır. python listesinde heterojen olabilir ama numpy arraylerinde arrayler homojen olmalıdır.

        import numpy as np

        x = np.array([1,2,'3'])
        print(x.dtype) # <U11    U11 karakterli unicode bir string demek. içerisinde string olduğu için hepsini stringe çevirdi...

içerisine bir tane string girince tüm elemanları stringe çevirdi buna Upcasting denir. çünkü homojen bir yapı olmalıdır.
    eğer int değerler içerisine float bir değer girerse o zaman yine Upcasting olur ve hepsi float olur. bunu .dtype ile görebiliriz. 

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



/////Ders 2 - Veri Tipleri - Save(), Load()////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

her veri homojen olmalı eğer verileri içerisinde farklı bir veri tipi varsa numpy ona göre tüm arrayi ayarlar mesela 3 tane int bir tane float var tüm değerler float olur.

        import numpy as np

        x = np.array([1,2,3.0])
        print(x.dtype) # float64 verdi...

..................

        import numpy as np

        x = np.array([1,2,3.0,'4'])
        print(x.dtype) #<U32 karakter setini verdi hepsini string galine çevirdi yani.

.................. dtype data type demektir. 


biz istersek eğer array'in tipini kendimiz belirleyebiliriz. mesela x = np.array([1,2,3],dtype = np.int) # ikinci parametre olarak biz dtype yolladık ve hangi tipte olacağını belirttik böylece istenen veri tipinde değerler ile array oluşturduk.

  python pythondosyasi.py ile istenen python dosyasını çalıştırabiliriz terminalde. 

str > float > int olarak kabul edebiliriz tiple bu sıralama ile dönüşür. 

        import numpy as np

        x = np.array([1,2,3,4],dtype=np.int8) # int 8 dmeek 8 bit yani 1 byte int 32 4 byte dmeek ama mesela int128 olursa eğer 128 bit yani 16 byte demektir... 
        print(x.dtype) # int8 olarak verir. istenen dtype ile verileri oluşturduk.

........................

        import numpy as np

        x = np.array([1,2,3,4],dtype=np.float64) 
        print(x.dtype) # float64 olarak verir tüm değerler float olarak kullanılır böylece.
        
........................


        import numpy as np

        x = np.array([1,2,3,4],dtype=np.float64) 
        print(x.dtype) # float64 olarak verir tüm değerler float olarak kullanılır böylece.
        
........................

        import numpy as np

        x = np.array([1,2,3,4],dtype=np.complex_)   
        print(x.dtype) # complex128 verir complex demek sanal ve reel kısmı olan sayı demek aslında.

.......................

alt + shift + a ile imleçte olan satırları yorum satırı yapabiliriz.
.......................

        import numpy as np

        x = np.array([1.5,2.5,3.6,4.3],dtype=np.int32) # veriler int olarak tutulacak. yani noktadan sonrası gidecek upcasting değil downcasting olacak. float veriden int dönüşümü yaptırdık bunu dtype ile yaptık.  
        print(x) #[1 2 3 4]
        print(x.dtype) # int 3

......................

        import numpy as np

        x = np.array([1,2,3,4],dtype=np.float64) # data type'ı dtype = ile float olarak belirledik.

        print(x)       # [1. 2. 3. 4.]
        print(x.dtype) # float64

        x = np.array(x,dtype=np.complex128) # verilerin tipini değiştirdik böylece. elde olan array ile veri tipi farklı bir array oluşturabildik. 

        print(x)       # [1.+0.j 2.+0.j 3.+0.j 4.+0.j]
        print(x.dtype) # complex128
        import numpy as np
   
    ,,,,,

    x = np.array([1,2,3,4],dtype=np.float64) # data type'ı dtype = ile float olarak belirledik.

    x = x.astype(np.complex128) # veri tipini direkt olarak bu metot ile değiştirebiliriz.

    print(x.dtype) # complex128

........................

        import numpy as np

        x1 = np.array([1,2,3], dtype=np.int64)
        x2 = np.array([1.4,2.6,3.6], dtype=np.float64)

        print(x1 + x2)       # [2.4 4.6 6.6]    verileri topladı kapsayıcı olan float olduğu için float değerler ile oluştu bu array
        print((x1+x2).dtype) # float64  kapsayıcı olan float olduğu için float oldu dtype...

.........................


    import numpy as np

    x = np.sqrt([-1,9,4], dtype=np.float64) # arrayin elemanlarının kökünü alacak np.sqrt()

    print(x) # [nan  3.  2.] neden nan var hata var = bunun sebebi -1 karmaşık sayıdır. kökü alınamaz ama dtype complex olsa idi hata olmazdı.

.........................

            import numpy as np

            x = np.sqrt([-1,9,4,-14],dtype=np.complex128) # verileri complex yaptık böylece kökü alınınca sorun olmayacak.

            print(x.real) # karmaşık sayıların reel kısmını gösterir sadece.
            print(x.imag) # karmaşık sayıların sanal kısımlarını gösterir sadece.

            print(x.real.dtype) # float64 
            print(x.imag.dtype) # float64 karmaşık sayıların değerleri float olarak tutulurmuş demekki.

.........................

        import numpy as np

        x = np.array([1,2,3,4,5],dtype=np.int64)
        np.save("fordfocus",x) # np.save ile array kaydederiz. önce kaydedilecek yer sonra ise kaydedilecek değeri gireriz ve .npy uzantılı bir dosyaya değerleri kaydeder.

        y = np.load("fordfocus.npy") # y = dosya içerisindeki ndarray olacak aslında. np.load() parametre alacak oda arrayin kaydedildiği .npy dosyası.

        print(y) # [1 2 3 4 5]
       
        np.save("dosyaadi",kaydedilecekarray) ile kaydederiz ndarrayi bir .npy dosyasına      y = np.load(.npy dosyasınınadi ve uzantısı) ile ise kaydedilmiş arrayi geri çıkartırız.

..............................




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////Ders 3 - Gömülü Fonksiyonlar I, ones, zeros, diag, eye...//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

hazır fonksiyonlar ile içeriye bir liste koymadan ndarray oluşturacağız. mesela x = np.arange(100) ile 0'dan 99'a kadar 99 dahil 100 elemanlı bir array oluştururuz...

    import numpy as np

    X = np.zeros(5) # 5 adet 0'dan oluşan bir array elde ederiz. np.zeros() ile oluşan array'in veri tipi float64'tür .dtype bize float64 verir.. 
    Y = np.ones(5) # 5 adet 1'den oluşan bir array elde ederiz. np.ones() ile oluşan array'in veri tipi float64'tür .dtype bize float64 verir.. 

................................

        import numpy as np

        X = np.zeros((2,3,4),dtype= np.int64) # içerisine bir tuple yollarız zeros metotunun. # 2 adet matris üret 3 satırdan oluşsun her matris ve satırlarda 4 eleman olsun demek (matrissayisi,satirsayisi,sutunsayisi)

        print(X)
        """
        [[[0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]]

        [[0 0 0 0]
        [0 0 0 0]
        [0 0 0 0]]]    
            
            """

................................

  nedens ones, zeros gibi metotlar kullanırız. numpy için önemli olan gelecek olan verilerdir. 

np.full() # bunun ile istenen sabit sayının olduğu bir array oluşturabiliriz.

        import numpy as np

        x = np.full((2,3),10) # 2 satır 3 sutun olsun içerisinde 10 olsun tüm elemanlar 10 olsun demektir.  veri türü ise int32 oldu. nedeni ise 3. parametre olarak gönderilen değerin veri tipi kullanılır 10.0 verse idik o zaman dtype float olacaktı.

        print(x)

        """
        [[10 10 10]
        [10 10 10]]
            
            """

.................................

        import numpy as np

        x = np.full((2,3),10.0) # (2,3) ile oluşacak arrayin yapısını belirttik. üçüncü parametre ile ise hangi değer ile donatılacak belirttik.
        y = 10.0 * np.ones((2,3)) # 2 satır 3 sutundan oluşan bir matris olacak her eleman 10.0 ile çarpılacak.
        z = 10.0 + np.zeros((2,3)) # 2 satır 3 sutundan oluşan bir matris ve her değer 10.0 ile toplanacak yani her değeer 10.0 olacak
        print(y)
        """
        [[10. 10. 10.]
        [10. 10. 10.]]    
            """

.................................


mesela arrayismi += 10 demek örnek olarak x = np.array([1,2,3,4,5,6]) demek ve sonraki satır x += 10 demek her elemana 10 eklemek demektir.

        import numpy as np

        x = np.array([1,2,3,4,5])
        x += 10
        print(x) # [11 12 13 14 15]

................................

np.empty() #  bu fonksiyon ile hafızada ndarray oluştururuz hafızada yer ayırırız ama elemanların değerini vermeyiz keyfi değerler bulunur.

    import numpy as np

    x = np.empty((2,3)) # içerisine bir tuple yolladık ve yapısını belirledik.
    print(x)
    """
    [[9.34577196e-307 9.34598246e-307 1.60218491e-306]
    [1.69119873e-306 1.24611673e-306 1.05699581e-307]]
    """ # görüldüğü gibi bellekte yer ayrıldı ancak değerler rastgele değerler...

    x.fill(10) # bununla birlikte ndarray'in elemanlarının hepsini 10 yaptık... boş olan bir array'i böylece doldurmuş olduk.

................................

ndarray.fill(sayi) metotu ile bir array'in tüm elemanlarını istenen sayı yapabiliriz. 

.................................

import numpy as np 
x = np.eye(4) # birim matris oluştururuz np.eye() ile diogonal olanlar 1 olmayanlar 0 olan matris oluştururuz.

        import numpy as np

        x = np.eye(4)
        print(x)
        """
        [[1. 0. 0. 0.]
        [0. 1. 0. 0.]
        [0. 0. 1. 0.]
        [0. 0. 0. 1.]]

        """ # np.eye() ile birim matris oluştururuz.

        y = np.eye(4,5) # 4 satır 5 sutunlu bir matris oluşturur. ve olabildiğince birim matris olmayaca çalışır. 

.................................

    import numpy as np

    x = np.eye(6)
    print(x)
    print("")
    y = np.eye(6,k = 1) # k = 1 olunca diegonali 1 birim yukarı aldı -2 olsa idi 2 birim aşağı inecekti.
    print(y)

.................................

            import numpy as np

            x = np.identity(5)
            print(x)
            """
            [[1. 0. 0. 0. 0.]
            [0. 1. 0. 0. 0.]
            [0. 0. 1. 0. 0.]
            [0. 0. 0. 1. 0.]
            [0. 0. 0. 0. 1.]]
            """ # 5 e 5 birim matris oluşturur...

.................................

        import numpy as np

        x = np.diag([4,7,11,3])
        print(x)
        """
        [[ 4  0  0  0]
        [ 0  7  0  0]
        [ 0  0 11  0]
        [ 0  0  0  3]]
            
            """ # np.diag(liste) # listenin elemanlarını diegonale yerleştirir ona göre bir matris oluşturur...

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////Ders 4 - Gömülü Fonksiyonlar II, arange - linspace, reshape, random/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

x = np.arange(5) # 0'dan başlar 5 tane elemandan oluşan bir array oluşturur.. 5 dahil değil.

y = np.arange(0,6,2) # 0dan başlar 5'e kadar oda dahil ikişer ikişer atlar ve bir array oluşturur.

                import numpy as np

                x = np.arange(10) # 0 1 2 3 4 5 6 7 8 9... 10 dahil değil. default olarak artım miktarı ise birdir. yarı açık bir aralık var.
                y = np.arange(5,10) # 5 dahil 10'a kadar 10 dahil değil bir array oluşturur. [5,10)
                z = np.arange(6,19,3) # 3. parametre ise artım miktarı olacak. [6,19) arasında 3er 3er artım olacak. 18 dahil 19 değil o aralıkta kapsayabildiğini alacak.

............................................. arange genellikle tamsayılar için kullanılır.

        import numpy as np

        x = np.linspace(0,15,10) # ilk argüman başlangıc noktası ikincisi bitiş noktası, 3. parametre ise kaça bölüneceği 10 olarak girdik 3. parametreyi 10 tane sayı elde edeceğiz. 
        # linspace fonksiyonunda kapalı fonksiyon vardır yani 0 ve 15 dahil [0,15] olarak geçer başlangıç ve bitiş dahildir.
        # tek boyutlu bir array getirir bize.
        # eğer 3. parametre olarak kaç adet eleman üretileceğini belirtmezsek default olarak 50 kabul edilir.
..............................................
  
  import numpy as np
  x = np.linspace(0,15,100,endpoint=False) # eğer endpoint False dersek o zaman bitiş noktası dahil olmaz. böylece son kısım açık aralık olur [0,15) olur. 

...............................................

        import numpy as np

        x = np.arange(20) # 20 elemalı tek boyutlu bir array 0'dan başlayacak. çünkü numpy sıfırdan numaraladırma yapar.
        x = np.reshape(x,(4,5)) # 4 satır 5 sutun. Önce hangi arrayi değiştireceğimizi sonra tuple içerisinde satır sutunu verdik. 5'e 5 versek hata verirdi çünük eleman sayısı yetersiz.
                          # np.reshape(x,(2,2,5)) # dese idik. 2 tane matris olacaktı ve her matris 2 satır 5 sutundan oluşacaktı.
        print(x)
        """
        [[ 0  1  2  3  4]
        [ 5  6  7  8  9]
        [10 11 12 13 14]
        [15 16 17 18 19]]
        """

...............................................

        import numpy as np

        x = np.arange(20).reshape(4,5) # 20 elemalı tek boyutlu bir array 0'dan başlayacak. çünkü numpy sıfırdan numaraladırma yapar.
        print(x) # reshape() ise içerisine tuple ve parçalanacak array gönderilmeden de kullanabiliriz. bu yapıda. içerisinde sayıları göndeririz ve bölme işlemini uygularız.
        """
        [[ 0  1  2  3  4]
        [ 5  6  7  8  9]
        [10 11 12 13 14]
        [15 16 17 18 19]]   
        """
...............................................

        import numpy as np

        x = np.random.random(10) # 10 tane sayı üretir. 0 ile 1 arasında 1 dahil değil.
        print(x) #[0.57100026 0.72277628 0.42328953 0.37058981 0.44240555 0.66137003 0.28446727 0.84857043 0.29600169 0.17329597]

...............................................

        import numpy as np

        x = np.random.random((2,3)) # 2 satır 3 sutundan oluşan bir matris elde ederiz sayılar ise 0 ile 1 arasında rastgele sayılar olur. 1' e eşit olmaz.
        y = np.random.randint(4,50,size = (2,3))  # 4den başla 50 dahil değil aralıkta rastgele bir array oluştur. size  ile nasıl bir yapıda olacağını belirtiriz. size = 5 desek tek boyutlu bir array oluştururuz. ama mesela shape ile ilgili bir işlem yapacaksak ve tek boyutlu olmayacaksa genellikle () tuple içerisnde gönderilir.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////Ders 5 - NDArray Değiştirmek, Insert, Append, Stack, Delete////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   

....................................................

        import numpy as np

        x = np.arange(5) # arraylar normal listeler gibi 0 index ile başlarlar.
        print(x[0]) #  ilk elemanı görebiliriz. 
        print(x[1]) # 2. elemana ulaşabiliriz. 
        print(x[x.size - 1]) # en son elemana ulaşabiliriz. x.size ile kaç tane eleman varsa görürüz ve -1 deriz indexleme 0'dan başlar çünkü.
        print(x[-1]) # en son elemana ulaşırız. negatif index olunca tersten -1 ile başlar -2 demek en sondaki 2. eleman demek. 5 elemanlı bir array ile -5 ile en baştaki elemana en sondan ulaşmış oluruz.
        print(x[-2]) # en sondan ikinci elemanı getirecek.
        print(x[2:]) # 2. indexteki elemandan en sona gitmek demektir. arrayi parçalarız.

        x[2] = 200 # bunu diyerek direkt atama ve değişim yapabiliriz. 2. indexteki yani 3. eleman 200 olur.
        x += 10 # bununla birlikte tüm elemanlar 10 artar.
        x *= 2 # bununla birlikte tüm elemanlar 2 ile çarpılır

....................................................

        import numpy as np

        x = np.arange(12).reshape(3,4) # 12 tane elaman oluşur ve 3 satır 4 sutun olarak oluşur.
        print(x[0]) # 0 indexteki satır gelir yani birinci satır gelir.
        print(x[0,0]) # 0 indexteki satırın 0 indexteki elemanı gelir yani 1. satırın 1. elemanı gelir.
        print(x[2,3]) # 2 .indexteki satırın 3. indexteki elemanı gelir yani en sağ alttaki eleman gelir.
        print(x[2]) # en sondaki satırı getirir. pointer mantığı ile ilerler.
        print(x[1,2]) # 2. satırın 3. elemanını getirir.  
        x[0,0] = 100 # ilk satırın ilk elemanı 100 olur atama yaparız.

....................................................


        import numpy as np

        x = np.arange(6)
        print(x) # [0 1 2 3 4 5]
        y = np.delete(x, [0,1]) # x arrayinin 0. ve 1. indexteki elemanlarını silecek. eğer orjinali değiştirmek  istersek o zaman y yerine x derdik direkt olarak değişim yapardık.
        print(y) # [2 3 4 5]

....................................................

axis = 0 olursa row yani satır
axis = 1 olursa column yani sutun demektir. 

....................................................

        import numpy as np

        x = np.arange(16).reshape(4,4) 

        print(x)

        """

        [[ 0  1  2  3]
        [ 4  5  6  7]
        [ 8  9 10 11]
        [12 13 14 15]]
        
        """

        y = np.delete(x,1,axis=0) # axis 0 olduğu için 1. indexteki yani 2. satırı siler. ama axis = 1 olsa idi 2. sutunu silerdi.
        print(y)

        """
        [[ 0  1  2  3]
        [ 8  9 10 11]
        [12 13 14 15]]
        
        """

        z = np.delete(x,1,axis=1) # axis 1 olduğu için sutun silecek ve yeni array oluşturacak. sonra atama olacak.
        print(z)
        """
        [[ 0  2  3]
        [ 4  6  7]
        [ 8 10 11]
        [12 14 15]]

        """
        
        t = np.delete(x,[1,3],axis=0) # 1. ve 3. indexteki satırları sildi satırlaro silmesinin sebebi ise axis = 0 diye.
        print(t)

        """
        [[ 0  1  2  3]
        [ 8  9 10 11]]

        """

        p = np.delete(x,[1,3],axis=1) # 1 . ve 3. indexteki sutunları sildi. sutun silmesinin sebebi ise axis = 1 diye
        print(p)
        """
        [[ 0  2]
        [ 4  6]
        [ 8 10]
        [12 14]]

        """


....................................................

        import numpy as np


        # np.append() bu fonksiyonu kullanıdığımızda buı işlemi yapacağımız matrislerin bu işleme uygun olması gerekir. önce parametre olarak değişecek olanı alır arrayi alır  yani sonra ne eklenecek onu yazarız en sona ekleme yapar.

        x = np.arange(5)
        print(x) # [0 1 2 3 4]
        x = np.append(x,100) # eleman alacak olan rray ve hangi değerin ekleneceğini girdik. en sona ekler.
        print(x) # [  0   1   2   3   4 100] 
        x = np.append(x,[100,200,300]) # birden fazla değer eklemek istersek eğer bir liste içerisinde yollayacağız.
        print(x) # [  0   1   2   3   4 100 100 200 300]

        y = np.arange(9).reshape(3,3) # sırası ile oluşacak bu matris ilk 3 eleman ilk satıra sonraki 3 eleman sonraki satıra olacak şekilde olacak.

        y = np.append(y,[[100,200,300]],axis=0) # axis 0 olduğu için satıra ekleme yapacağız. satıra ekleme yapacağımız için sutun eleman sayısına göre ekleme yapacağız.
        print(y)

        """
        [[  0   1   2]
        [  3   4   5]
        [  6   7   8]
        [100 200 300]]
        
        """

        y = np.append(y,[[77],[77],[77],[77]],axis=1) # sutuna eleman ekleyeceğiz 4 satır olduğu için 4 tane eleman eklememiz lazım. bu sutun en sondaki sutun olacak. her sutun elemanı tek tek bir liste içerisinde yollandı çünkü aslında tek tek satır ekliyoruz. 
        print(y)

        """
        [[  0   1   2  77]
        [  3   4   5  77]
        [  6   7   8  77]
        [100 200 300  77]]

        """
        

....................................................

        import numpy as np

        # np.stack() vstack(vertical = dikey) ve hstack(hortizonal = yatay) olarak kullanacağız.

        x = np.arange(3)

        y = np.arange(9).reshape(3,3)

        print(y)

        """

        [[0 1 2]
        [3 4 5]
        [6 7 8]]
        
        """

        z = np.vstack((x,y)) # x'i y'ye dikey olarak ekle demek. x'i y'nin en üstüne yerleştirir. ilk satıra satır olarak yerleştirir.
        print(z)

        """
        [[0 1 2]
        [0 1 2]
        [3 4 5]
        [6 7 8]]
        
        """

        t = np.hstack((x,y.reshape(9,))) # x'i y'ye yatay olarak ekle. y = y.reshape(9,0) yapabilirdik bir satır yukarıda. ama direkt olarak içeride de y.reshape(9,0) yaparak 9 elemanlı tek boyutlu bir array haline çevirebiliriz 2 boyutlu bir arrayi.
        print(t)

        """
        [0 1 2 0 1 2 3 4 5 6 7 8] # y.reshape(9,0) diyerek tek boyutlu hale çevirdik ve öyle yatay ekleme yaptık x'in elemanlarını y'nin en başına ekledi.
        """
....................................................

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////Ders 6 - Slicing - copy()/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        import numpy as np

        # ndarray[başlamanoktası:end(dahil değil):artış miktarı], ndarray[start:] başlama elemanında sona kadar git demektir. ndarray[:end] başlangıç noktasından ende kadar ama end dahil değil.

        x = np.arange(10)
        y = x[5:] # x'in bir bölümünü alır ve bir array oluşturur bunuda y'ye atar y'de bir array olur.
        print(type(y)) #<class 'numpy.ndarray'>

        print(x[:6]) # 6. indexe kadar gidecek 6 dahil değil. başlangıç noktasından itibaren. arrayden bir array oluşturur. 

        print(x[::-1]) # en sondan en başa teker teker gel demek.
        print(x[-1::-2]) # en sondan en başa ikişer ikişer gel demek

        print(x[-4:-2]) # en sondan 4. elemandan en sondan 2. elemana ama en sondan 2. eleman dahil değil.

        t = np.arange(25).reshape(5,5)
        print(t)
        """
        [[ 0  1  2  3  4]
        [ 5  6  7  8  9]
        [10 11 12 13 14]
        [15 16 17 18 19]
        [20 21 22 23 24]]
        
        """

        print(t[:2]) # birinci satırı ve ikinci satırı getirir. pointer mantığı ile eleman aslında satırdır. ilk olarak girilen satırdır 2:4,1:3 bu parametrelerde eğer sutun bilgisi vermezsek o zaman satırlar üzerinden işlem yaparız.

        """
        [[0 1 2 3 4]
        [5 6 7 8 9]]
        
        """

        print(t[:2,2:]) # satır ve sutun ayrı olarak işlem olacak :2 satır başlangıç satırından 2. satıra kadar 2.satır dahil değil VE 2. sutundan sonuncu sutuna kadar son dahil olan aralığı al demek.

        """
        [[2 3 4]
        [7 8 9]]

        """

        print(t[:,1:4]) # tüm satırlar dahil sutun olarak ise 1. indexten 4. indexe 4 dahil değil.

        """
        [[ 1  2  3]
        [ 6  7  8]
        [11 12 13]
        [16 17 18]
        [21 22 23]]
        
        """

        print(t[:,:]) # satırlar ve sutunlar için bir kısıtlama yok t'nin aynısı olur.

        """
        [[ 0  1  2  3  4]
        [ 5  6  7  8  9]
        [10 11 12 13 14]
        [15 16 17 18 19]
        [20 21 22 23 24]]
        """



        u = np.arange(9).reshape(3,3)
        print(u)

        """
        [[0 1 2]
        [3 4 5]
        [6 7 8]]

        """

        i = u[1:2,0:2] # 1. satır olacak ve sutunlardan ise 0. ve 1. index dahil olacak.
        print(i)
        """
        [[3 4]]

        """

        u[1,1] = 100 # 2.satır 2.sutundaki eleman 100 oldu.   : işareti ile aralık belirleriz. , ile ise satır sutun belirlemesi yaparız.
        i[0,0] = 333 # ilk satır ilk sutundaki eleman 333 oldu...
        print(u)
        """
        [[  0   1   2]
        [333 100   5]
        [  6   7   8]]

        """ # u'nun bir parçası olan i üzerinde işlem yapmamıza rağmen u'da değişim oldu bunun nedeni referanslar ile bellek adresleri ile işlem yapmak aslında bellek adresinin bir kısmını alıp array olarak atıyoruz. bu yüzden parçada olan değişim ana arraydede etki eder çünkü o bellek alanı üzerinde değişim oldu.

        print(np.shares_memory(u,i)) # aynı bellek adresinde mi çalışıyorlar True verir... hafızadaki yerleri aynı ortak elemanların bu yüzden yapılan bir değişim diğerinede etki ediyor.

        # farklı bellek adresleri olsun istersek o zaman .copy() metotunu kullanacağız...


        g = np.arange(16).reshape(4,4)

        h = np.copy(g[:3,1:4]) # g'den kopyala ve yeni bir yere ata. değerler farklı bellek gözlerinde olsun istiyoruz.
        print(h)
        """
        [[ 1  2  3]
        [ 5  6  7]
        [ 9 10 11]]
        
        """

        print(np.shares_memory(g,h)) # False verir çünkü değerleri aynı bellek adreslerinde saklamıyor. .copy() ile sadece değerler alınır bellek adreslerinin farklı olması sağlanır.  

        j = g[:,2:].copy() # elde edilen array'i copy ile farklı bellek gözlerindeki bir yere atarız. .copy() ile direkt olarak böylece iki array'in elemanlar farklı bellek adreslerinde olur ve bellekte elemanların kesişimi olmaz.
        
        # birbirinden farklı ama elemanları aynı veya bir bölümü alınmış referansları farklı arrayler için .copy() metotunu kullanmak gerekir.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////Ders 7 - Fancy, Boolean Indexing/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import numpy as np

        x = np.linspace(1,21,11)
        print(x) # [ 1.  3.  5.  7.  9. 11. 13. 15. 17. 19. 21.]
        y = np.array([2,4,7])
        print(x[y]) # [ 5.  9. 15.] bu ne demek = x'in içindeki y değerlerindeki indexlerden oluşan değerlerden bir array elde et ve getir demek. yani bir array halinde gitti y buraada her değeri bir işlem gördü ve bir array döndürdük. 

        t = np.arange(25).reshape(5,5)
        print(t)
        z = np.array([1,2])
        print(t[z,:]) # satırlarda z yani 1. index ve 2. index sutunlarda ise hepsini alacağız. z'nin tüm değerleri işlem görecek.
        """
        [[ 5  6  7  8  9]
        [10 11 12 13 14]]
        
        """

        u = t[z,:] 
        print(np.shares_memory(u,t)) # False verir. .copy() demekse bile. bir arrayi başka bir arrayin yardımı ile slicing ettiysem eğer o zaman bellekteki farklı bir yerde değerleri konumlandırır.


        u[0,0] = 1000
        print(t) # bir değişim olmadı .copy() ile içerik üretmediğimiz halde. bir ndarrayi başka bir ndarray ile slicing ettiysek eğer o zaman oluşan array bellekte ana arrayden farklı bir yer oluşur.

        # fancy indexing... bir arrayi eğer başka bir array ile elde ediyorsak buna denir. bir arrayin alt kümesine başka bir array sayesinde ulaşırız ve oluşan array orjinal arrayden bağımsız bellek ortaklıkları yok.

....................................................

        import numpy as np

        # boolean indexing 

        x = np.arange(10)
        print(x) # [0 1 2 3 4 5 6 7 8 9]
        print(x[(x % 2 == 0)]) # [0 2 4 6 8] bana x'in elemanlarından 2 ile bölümü sıfır olanları bir array içerisinde dönder demek.

        z = x[(x % 2 == 0)]
        z[0] = 100 # z üzerinde yapılan değişim ana arrayi etkilemez çünkü bellek alanları farklı 
        # slicing ile yapılan işlemde bellek ortak kullanılır ama fancy ve booelan indexing'de bellek alanları farklı olur oluşan arraylerde.
        print(np.shares_memory(x,z)) # False verir. boolean indexing ile oluşan alt küme ana arrayden bağımsızdır. farklı bellek adresinde oluşur. 

        u = np.random.randint(0,10,size=10)
        i = np.random.randint(0,10,size=10)
        print(u > i) # [ True  True False  True False  True False  True False  True] her eleman üzerinde karşılaştırma oldu. ve koşulan uyanlar True uymayanlar ise False verdi.
        print(type(u > i)) # <class 'numpy.ndarray'> class'ı ise ndArrayDir.
        print((u > i).dtype) # bool boolean veri tipi ile oluşmuştur oluşan yeni array.
 
        print(np.all(u > i)) # False eğer u'nun elemanlarının tamamı i'den büyük olsa idi yani koşulu sağlasa ve homojen bir array elde etseydi True olurdu.
        print(np.any(u > i)) # True eğer bir tane bile homojenliği bozan eleman varsa True verir.


....................................................

        import numpy as np

        x = np.linspace(1,21,11)
        print(x)
        mask = x % 3 == 0  
        print(type(mask)) # <class 'numpy.ndarray'>
        print(mask) # [False  True False False  True False False  True False False  True]   mask = x % 3 == 0 yaparsak eğer boolean bir array elde ederiz 3e bölümmden kalan 0 olanlar True olmayanlar False olur ve böyle bir array elde ederiz.
        print(x[x % 3 == 0]) #[ 3.  9. 15. 21.]
        print(x[mask]) # [ 3.  9. 15. 21.] x üzerinden tüm mask elemanlarını geçirir ve True olanlarla koşulu sağlayanlar ile bir array oluştururuz.
        x[mask] = -3 # True olanları -3 olarak değiştirdi. maskeleme yaptı...
        print(x) # [ 1. -3.  5.  7. -3. 11. 13. -3. 17. 19. -3.] # koşulu sağlayanlara -3 atandı.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////Ders 8 - Grup İşlemleri, Sıralama/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        import numpy as np

        # grup ve küme işlemleri... set operations. genellikle iki tane arrayi karşılaştırırken kullanırız.

        x = np.array([2,5,3,6,9])
        y = np.array([6,1,8,7,3])
        z = x[x > y] # x'in içindeki ve sırası ile indexler karşılıklı olarak karşılaştırınca koşulu sağlayan elemanlardan oluşan bir array elde ederiz.
        print(z) # [5 9]


        print(np.intersect1d(x,y)) # [3 6] ortak elemanlardan oluşan yani kesişimden oluşan bir array getirir. iki arrayin kesişiminden array oluşturur.

        t = np.intersect1d(x,y)
        print(type(t)) # <class 'numpy.ndarray'>


        print(np.setdiff1d(x,y)) # [2 5 9] x'de olan ancak y'de olmayan elemanları bize gösterecek... bir array geri dönecek.
        print(np.setdiff1d(y,x)) # [1 7 8] y'de olan x'de olmayan elemanları bir array içerisinde return edecek.

        print(np.union1d(x,y)) # [1 2 3 5 6 7 8 9] iki arrayin birleşiminden elde edilen elemanlardan oluşan bir array döndürür. neden 8 eleman var çünkü kesişim iki kere yazılmadı bir kere olacak.

        print(np.in1d(x,y)) # [False False  True  True False] x'de olan bir elemanın y'de olup olmadığını bir array içerisinde True False biçiminde tutacak ve bunu döndürecek. eğer y,x yapsa idik y'de olup x'de olmayan elemanlar False olanlar True alacak ve bir array oluşacaktı.

....................................................

        import numpy as np


        x = np.array([2,5,3,6,9,4,3,6,5,0])
        print(np.unique(x)) # [0 2 3 4 5 6 9] tekrarlardan arındırılmış bir halde bize getirdi elemanları. set gibi düşünebiliriz.

        # sorting... (sıralama).

        y = np.random.randint(1,10,size = (10,)) # size = (10,) diyerek tek boyutlu 10 elemanlı bir array oluştur dedik.
        print(y) # [2 5 3 5 5 4 1 7 5 8]
        print(np.sort(y)) # [1 2 3 4 5 5 5 5 7 8] küçükten büyüğe sıralama yapar. sıralanmış arrayi return eder. y'de değişim olmaz ayrı bir array oluşturur.
        print(y) # [2 5 3 5 5 4 1 7 5 8] görüldüğü gibi np.sort() yapısı ana arrayde bir değişim yapmadı. sıralanmış bir array return eder ama kalıcı bir değişim yapmaz.


        u = np.random.randint(1,10,size = (10,))
        print(u) # [4 2 2 9 6 6 2 9 7 3]
        u.sort() # sıralama yaparız ve kalıcı olarak değişir u.  eğer i = u.sort() deseydikte u sıralanmış olacaktı çünkü direkt olarak bellekteki veriler üzerinden sıralama yapar.
        print(u) # [2 2 2 3 4 6 6 7 9 9]

....................................................

        import numpy as np

        x = np.random.randint(1,10,size=(5,5)) # size = (5,5) 5 satır 5 sutundan oluşsun dedik bir matris oluşturacak.
        print(x)
        """
        [[4 4 1 1 5]
        [9 1 4 8 7]
        [2 6 9 8 9]
        [7 2 4 3 6]
        [3 1 4 5 2]]
        """ 
        print(np.sort(x,axis=0)) # axis = 0 olursa sutunları kendi arasında sıralar(aynı sutun farklı satırlardaki elemanları sıralar) ama eğer axis = 1 olursa o zaman satırları kendi arasında sıralar(aynı satırdaki ama farklı sutunlardaki elemanları sıralar.).
        """
        [[2 1 1 1 2]
        [3 1 4 3 5]
        [4 2 4 5 6]
        [7 4 4 8 7]
        [9 6 9 8 9]]
        """



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///Ders 9 - Matematiksel İşlemler, element-wise vs array-wise//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

....................................................





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

....................................................

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

....................................................

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


####################################################################################################################################################################################################################################################################################################################################